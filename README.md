### Entity-Level Annotations in Hibernate

In Hibernate, **entity-level annotations** are used to define the mapping between Java classes and database tables. These annotations provide a way to mark Java classes as entities that Hibernate will map to database tables, and to configure how these mappings are made.

### Key Entity-Level Annotations

1. **`@Entity`**: Marks a class as a Hibernate entity (mapped to a database table).
2. **`@Table`**: Defines the name of the table that the entity will be mapped to.
3. **`@Id`**: Marks the primary key of the entity.
4. **`@GeneratedValue`**: Specifies how the primary key is generated.
5. **`@Column`**: Maps a Java field to a database column.
6. **`@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`**: Define relationships between entities.
7. **`@JoinColumn`**: Specifies the column used for joining two entities.
8. **`@Transient`**: Marks a field that should not be persisted to the database.

Let's go through these annotations with detailed examples.

---

### Example: `Employee` Entity Class with Annotations

#### 1. `@Entity` and `@Table`
The `@Entity` annotation tells Hibernate that this class is an entity, and the `@Table` annotation specifies the table name in the database.

```java
import javax.persistence.Entity;
import javax.persistence.Table;

@Entity
@Table(name = "employees") // This defines the table name in the database
public class Employee {
    // Fields and methods
}
```

#### 2. `@Id` and `@GeneratedValue`
The `@Id` annotation marks the primary key field. The `@GeneratedValue` annotation is used to specify the strategy for generating the primary key value.

```java
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Identity strategy for auto-incrementing ID
    private Integer employeeId;

    // Other fields and methods
}
```

In this example, `GenerationType.IDENTITY` means that the primary key (`employeeId`) is auto-generated by the database (commonly used with MySQL, for example).

Other strategies:
- `GenerationType.AUTO`: Hibernate decides which strategy to use based on the database.
- `GenerationType.SEQUENCE`: Uses a sequence to generate IDs (used with databases like PostgreSQL).
- `GenerationType.TABLE`: Uses a separate table to generate IDs (less common).

#### 3. `@Column`
The `@Column` annotation is used to map a Java field to a database column. By default, Hibernate maps the Java field name to the column name, but you can customize it using `@Column`.

```java
import javax.persistence.Column;

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer employeeId;

    @Column(name = "name") // This will map the "name" field to the "name" column in the database
    private String employeeName;

    @Column(nullable = false) // Mark the field as non-nullable
    private String email;

    // Getters and setters
}
```

- **`name`**: The column name in the database is explicitly defined.
- **`nullable`**: Ensures that this column is non-nullable.

#### 4. `@Transient`
The `@Transient` annotation marks a field that should not be persisted in the database.

```java
import javax.persistence.Transient;

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer employeeId;

    private String employeeName;

    @Transient
    private int temporaryField; // This field will not be saved in the database

    // Getters and setters
}
```

#### 5. `@ManyToOne` and `@OneToMany` (Relationships)
Hibernate also supports various relationship annotations, such as `@ManyToOne`, `@OneToMany`, `@OneToOne`, and `@ManyToMany`.

Example of a `@ManyToOne` relationship between `Employee` and `Department` (each employee belongs to one department).

```java
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer employeeId;

    private String employeeName;

    @ManyToOne // Many employees belong to one department
    @JoinColumn(name = "department_id") // The column in the "employees" table that references the "departments" table
    private Department department;

    // Getters and setters
}
```

In this case, `@ManyToOne` indicates that many employees can belong to one department, and `@JoinColumn` specifies the foreign key column (`department_id`) that links the `employees` table to the `departments` table.

For the `Department` entity, you would have:

```java
import javax.persistence.OneToMany;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.util.List;

@Entity
@Table(name = "departments")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer departmentId;

    private String departmentName;

    @OneToMany(mappedBy = "department") // One department can have many employees
    private List<Employee> employees;

    // Getters and setters
}
```

#### 6. `@OneToOne` and `@ManyToMany`
- **`@OneToOne`**: Used for one-to-one relationships (e.g., one employee has one office).
- **`@ManyToMany`**: Used for many-to-many relationships (e.g., a student can enroll in many courses, and a course can have many students).

Example of `@OneToOne`:

```java
import javax.persistence.OneToOne;
import javax.persistence.JoinColumn;

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer employeeId;

    private String employeeName;

    @OneToOne
    @JoinColumn(name = "office_id")
    private Office office;

    // Getters and setters
}
```

Example of `@ManyToMany`:

```java
import javax.persistence.ManyToMany;
import javax.persistence.JoinTable;
import javax.persistence.JoinColumn;
import java.util.Set;

@Entity
@Table(name = "students")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer studentId;

    private String studentName;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses;

    // Getters and setters
}
```

In this example, a student can enroll in many courses, and a course can have many students.

---

### Complete Example: `Employee` with All Annotations

Here is a complete example using all the annotations:

```java
import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer employeeId;

    @Column(name = "employee_name", nullable = false)
    private String employeeName;

    @Column(nullable = false)
    private String email;

    private Double salary;

    @Temporal(TemporalType.DATE)
    @Column(name = "date_of_joining")
    private Date dateOfJoining;

    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;

    @Transient
    private String temporaryField;

    // Getters and setters
}
```

This `Employee` class demonstrates:
- Basic mapping of an entity to a table (`@Entity`, `@Table`).
- Mapping a primary key (`@Id`, `@GeneratedValue`).
- Mapping columns with custom names (`@Column`).
- Using relationships (`@ManyToOne`, `@JoinColumn`).
- Using `@Transient` for fields not to be persisted.

---

### Conclusion

- **`@Entity`** marks the class as an entity.
- **`@Table`** specifies the table name.
- **`@Id`** defines the primary key.
- **`@GeneratedValue`** specifies how the primary key is generated.
- **`@Column`** customizes column names and properties.
- **`@ManyToOne`, `@OneToMany`, etc.** define entity relationships.
- **`@Transient`** marks fields to be excluded from persistence.

These annotations help you define how your Java objects interact with the underlying database schema, giving you fine-grained control over entity mapping, relationships, and persistence.
